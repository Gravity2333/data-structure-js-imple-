// 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，
// 前面 正好 有 ki 个身高大于或等于 hi 的人。

// 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

// 示例 1：

// 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
// 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
// 解释：
// 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
// 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
// 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
// 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
// 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
// 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
// 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

/**
 * 思路 [hi,ki] 表示 身高 hi的人 前面有 ki 个身高大于 hi的人
 * 1. 先对身高进行排序，此时对于某个 hi ki 起前面的人都是身高 >= hi的，那么此时我们就可以向前移动来调整k，不用考虑h的排列
 * 2. 移动到 ki的位置即可 需要注意 题目说 >= 也就是 如果h相同的情况下，我们不能把k更小的排到k更大的前面
 *  _ _ _ 2 1
 *  _ _ 2 _ 1
 *  _ 1 _ 2 _ ❌
 *
 *  _ _ _ 1 2
 *  _ 1 _ _ 2
 *  _ 1 _ 2 _ 可以加入到后面 ✅
 *  所以 先按照h排序 身高同 按照k从小到大排序
 */

/**
 * @param {number[][]} people
 * @return {number[][]}
 */
var reconstructQueue = function (people) {
  people.sort((p1, p2) => (p2[0] === p1[0] ? p1[1] - p2[1] : p2[0] - p1[0])); // 倒序排序
  for (let i = 0; i < people.length; i++) {
    const [h, k] = people[i];
    let currPtr = i;
    while (currPtr > k) {
      // 后移前面的元素
      people[currPtr] = people[currPtr - 1];
      currPtr--;
    }
    people[currPtr] = [h, k];
  }
  return people;
};
