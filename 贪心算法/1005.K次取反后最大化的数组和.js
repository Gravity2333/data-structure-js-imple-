// 1005. K 次取反后最大化的数组和
// 已解答
// 简单
// 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：

// 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
// 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。

// 以这种方式修改数组后，返回数组 可能的最大和 。

// 示例 1：

// 输入：nums = [4,2,3], k = 1
// 输出：5
// 解释：选择下标 1 ，nums 变为 [4,-2,3] 。
// 示例 2：

// 输入：nums = [3,-1,0,2], k = 3
// 输出：6
// 解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
// 示例 3：

// 输入：nums = [2,-3,-1,5,-4], k = 2
// 输出：13
// 解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。

/** 
 * 这破题给我整吐了 代码很难写
 * 总结一下思路 这个题存在2次贪心
 * 
 * 
 * 第一次 把所有的负值 都 转正 
 * 对数组排序，从最小值开始 如果是 负数 就反转 正值跳过
 * 
 * 第二次 如果还剩下 k ，那么就看 如果k是偶数 就等于没变化
 * 如果k是奇数 那么 把正数中最小的值反转 这是第二次贪心 
 * 对nums再次排序
 * 把最小值 反转
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var largestSumAfterKNegations = function (nums, k) {
  /** 排序 */
  nums.sort((a, b) => a - b);
  /** 反转 */
  for (let i = 0; i < nums.length; i++) {
    if (k > 0 && nums[i] < 0) {
      nums[i] = -nums[i];
      k--;
    }
  }

  if(k>0 && k % 2 !==0){
      nums.sort((a, b) => a - b);
      nums[0] = -nums[0]
  }

  return nums.reduce((prev, curr) => prev + curr, 0);
};
