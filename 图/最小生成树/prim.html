<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Prim 最小生成树</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }

        .top-bar {
            padding: 10px 20px;
            background-color: #ffffff;
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            gap: 15px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .top-bar label {
            font-weight: bold;
            margin-right: 5px;
        }

        .top-bar input,
        .top-bar textarea {
            font-size: 14px;
            padding: 6px 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
            outline: none;
            background-color: #fefefe;
            color: #333;
            resize: none;
        }

        .top-bar button {
            padding: 6px 14px;
            border: none;
            border-radius: 5px;
            background-color: #4f83cc;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
        }

        .top-bar button:hover {
            background-color: #3b69a1;
        }

        .container {
            display: flex;
            width: 100%;
            height: calc(100% - 70px);
        }

        svg {
            width: 50%;
            height: 100%;
            cursor: grab;
            border-left: 1px solid #ddd;
            background-color: #fafafa;
        }

        .link {
            stroke: #88c0d0;
            stroke-width: 2px;
        }

        .node circle {
            stroke: #555;
            stroke-width: 2px;
            fill: #82aaff;
            transition: fill 0.3s;
            color: white;
        }

        .node circle:hover {
            fill: #6699ff;
        }

        text {
            font-size: 14px;
            fill: #ffffff;
            /* 改成白色 */
            font-weight: bold;
            pointer-events: none;
        }

        .weight {
            fill: #d64545;
            font-weight: bold;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <div class="top-bar">
        <div>
            <label>节点数 V:</label>
            <input type="number" id="nodeCount" value="7" min="1">
        </div>
        <div>
            <label>边数 E:</label>
            <input type="number" id="edgeCount" value="11" min="0">
        </div>
        <div>
            <label>边列表 (每行: 起点 终点 权重):</label><br>
            <textarea id="edgeList" rows="5" cols="40">1 2 1
1 3 1
1 5 2
2 6 1
2 4 2
2 3 2
3 4 1
4 5 1
5 6 2
5 7 1
6 7 1</textarea>
        </div>
        <div style="display:flex; flex-direction:column; gap:5px;">
            <button id="fullGraphBtn">生成完整图</button>
            <button id="mstGraphBtn">生成最小生成树</button>
        </div>
    </div>

    <div class="container">
        <svg id="fullGraph"></svg>
        <svg id="mstGraph"></svg>
    </div>

    <script>
        // ==================== Prim 算法 ====================
        function edgesToGrid(edges, n) {
            const grid = Array.from({ length: n + 1 }, () =>
                new Array(n + 1).fill(Infinity)
            );

            edges.forEach((edge) => {
                const [from, to, weight] = edge;
                grid[from][to] = grid[to][from] = weight;
            });

            return grid;
        }

        function getMinDistanceIndex(distances, visited) {
            let minIndex = Infinity;
            let minValue = Infinity;
            for (let i = 0; i < distances.length; i++) {
                if (distances[i] < minValue && !visited[i]) {
                    minIndex = i;
                    minValue = distances[i];
                }
            }
            return minIndex == Infinity ? -1 : minIndex;
        }

        function buildEmptyGrid(nodeNum) {
            const result = Array.from({ length: nodeNum + 1 }, () =>
                new Array(nodeNum + 1).fill(Infinity)
            );
            for (let i = 0; i < result.length; i++) {
                result[i][i] = 0;
            }
            return result;
        }

        function prim(edges, nodeNum) {
            const grid = edgesToGrid(edges, nodeNum);
            const distances = new Array(nodeNum + 1).fill(Infinity);
            const visited = new Array(nodeNum + 1).fill(false);
            const result = buildEmptyGrid(nodeNum);

            // 上一个加入的节点
            let lastAddNode = 1;
            for (let i = 0; i < nodeNum - 1; i++) {
                // 更 visited
                visited[lastAddNode] = true;
                // 获取neighbour
                const neighbours = grid[lastAddNode];
                // 更新distance
                neighbours.forEach((neighbour, index) => {
                    if (neighbour < distances[index]) {
                        distances[index] = neighbour;
                    }
                });
                // 获取最小的距离
                const minNeighborIndex = getMinDistanceIndex(distances, visited);
                if (minNeighborIndex === -1) break;
                // 加入最小生成树
                result[minNeighborIndex][lastAddNode] = result[lastAddNode][
                    minNeighborIndex
                ] = distances[minNeighborIndex];
                // 更新 lastAddNode
                lastAddNode = minNeighborIndex;
            }
            return result;
        }

        // ==================== 渲染图函数 ====================
        function renderGraph(svgId, nodes, links) {
            const svg = d3.select(svgId);
            svg.selectAll("*").remove(); // 清空旧图
            const width = svg.node().clientWidth;
            const height = svg.node().clientHeight;

            const g = svg.append("g");

            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(150))
                .force("charge", d3.forceManyBody().strength(-500))
                .force("center", d3.forceCenter(width / 2, height / 2));

            const link = g.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .join("line")
                .attr("class", "link");

            const linkText = g.append("g")
                .attr("class", "link-labels")
                .selectAll("text")
                .data(links)
                .join("text")
                .attr("class", "weight")
                .text(d => d.weight);

            const node = g.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(nodes)
                .join("g");

            node.append("circle").attr("r", 25);

            node.append("text")
                .attr("dy", 8)
                .attr("text-anchor", "middle")
                .text(d => d.id);

            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node.attr("transform", d => `translate(${d.x},${d.y})`);

                linkText
                    .attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2);
            });

            svg.call(d3.zoom()
                .scaleExtent([0.3, 3])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                }));
        }

        // ==================== 获取输入数据 ====================
        function getInputData() {
            const V = parseInt(document.getElementById("nodeCount").value);
            const E = parseInt(document.getElementById("edgeCount").value);
            const edgeText = document.getElementById("edgeList").value.trim();
            const edges = edgeText.split("\n").map(line => line.trim().split(/\s+/).map(Number));
            const nodes = Array.from({ length: V }, (_, i) => ({ id: i + 1 }));
            return { nodes, edges, V, E };
        }

        // ==================== 按钮事件 ====================
        document.getElementById("fullGraphBtn").addEventListener("click", () => {
            const { nodes, edges } = getInputData();
            renderGraph("#fullGraph", nodes, edges.map(e => ({ source: e[0], target: e[1], weight: e[2] })));
        });

        document.getElementById("mstGraphBtn").addEventListener("click", () => {
            const { nodes, edges, V } = getInputData();
            const mstMatrix = prim(edges, V);

            const mstLinks = [];
            // 注意 i,j 从 1 到 V
            for (let i = 1; i <= V; i++) {
                for (let j = i + 1; j <= V; j++) {
                    if (mstMatrix[i][j] !== Infinity && i !== j) {
                        mstLinks.push({ source: i, target: j, weight: mstMatrix[i][j] });
                    }
                }
            }
            renderGraph("#mstGraph", nodes, mstLinks);
        });

    </script>
</body>

</html>